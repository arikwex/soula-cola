<html><title>Soula Cola</title><link rel="shortcut icon"/><style>body{overflow:hidden;background:#000;margin:0px;font-family:sans-serif;}h1{color:#fff;text-align:center;margin-top:30px;}img{position:fixed;top:280px;width:600px;left:50%;margin-left:-300px;}h2{color:#666;font-style:italic;text-align:center;}</style><canvas></canvas><script>(() => {
  // src/bus.js
  var HANDLES = {};
  function on(e, handler) {
    (HANDLES[e] || (HANDLES[e] = [])).push(handler);
  }
  function off(e, handler) {
    HANDLES[e] = (HANDLES[e] || []).filter((x) => x != handler);
  }
  function emit(e, data) {
    (HANDLES[e] || []).map((handler) => handler(data));
  }

  // src/canvas.js
  var canvas = document.getElementsByTagName("canvas")[0];
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  window.onresize = () => {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    ctx.imageSmoothingEnabled = false;
  };
  var ctx;
  function retainTransform(fn) {
    const xfm = ctx.getTransform();
    fn();
    ctx.setTransform(xfm);
  }
  var favicon = document.createElement("canvas");
  favicon.width = favicon.height = 64;
  ctx = favicon.getContext("2d");
  ctx = canvas.getContext("2d");
  var link = document.querySelector("link");
  link.href = favicon.toDataURL();
  ctx.imageSmoothingEnabled = false;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  // src/tags.js
  var TAG_CAMERA = 0;

  // src/engine.js
  var gameObjects = [];
  var gameObjectsByTag = {};
  var objectsToRemove = [];
  var lastFrameMs = 0;
  function tick(currentFrameMs) {
    const dT = Math.min((currentFrameMs - lastFrameMs) * 1e-3, 0.018);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.textBaseline = "middle";
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    const zoom = Math.min(
      canvas.width / 1100,
      canvas.height / 800
    );
    ctx.setTransform(zoom, 0, 0, zoom, canvas.width * 0.5, canvas.height * 0.54);
    resort();
    retainTransform(() => {
      const camera = getObjectsByTag(TAG_CAMERA)[0];
      if (camera) {
        camera.set(ctx);
      }
      objectsToRemove.length = 0;
      gameObjects.map((g) => {
        if (g.update?.(dT)) {
          objectsToRemove.push(g);
        }
      });
      if (objectsToRemove.length) {
        remove(objectsToRemove);
      }
      if (camera) {
        gameObjects.map((g) => {
          if (g.inView(camera.x, camera.y)) {
            g.render?.(ctx);
          }
        });
      } else {
        gameObjects.map((g) => {
          g.render?.(ctx);
        });
      }
      lastFrameMs = currentFrameMs;
    });
    requestAnimationFrame(tick);
  }
  function add(obj) {
    if (!obj.inView) {
      obj.inView = () => 1;
    }
    gameObjects.push(obj);
    resort();
    obj.tags?.map((tag) => {
      gameObjectsByTag[tag] = gameObjectsByTag[tag] ?? [];
      gameObjectsByTag[tag].push(obj);
    });
  }
  function resort() {
    gameObjects.sort((a, b) => (a.order || 0) - (b.order || 0));
  }
  function arrayRemove(list, valuesToEvict) {
    valuesToEvict.forEach((obj) => {
      obj.onRemove?.();
    });
    return list.filter((g) => !valuesToEvict.includes(g));
  }
  function remove(objList) {
    gameObjects = arrayRemove(gameObjects, objList);
    objList.map((obj) => {
      obj.tags?.map((tag) => {
        gameObjectsByTag[tag] = arrayRemove(gameObjectsByTag[tag], [obj]);
      });
    });
  }
  function getObjectsByTag(tag) {
    return gameObjectsByTag[tag] || [];
  }
  requestAnimationFrame(tick);

  // src/events.js
  var SIGIL_DRAWN = 0;
  var RUNESTONE_MOVE = 1;
  var POWERUP_ACQUIRED = 2;
  var RUNESTONE_LAND = 3;
  var ENEMY_DAMAGE = 6;
  var ENEMY_BONK = 7;
  var ABILITY_BEAT = 8;
  var ENEMY_TAKE_DAMAGE = 9;
  var ENEMY_MOVE = 10;

  // src/audio.js
  function clamp(v, a, b) {
    return Math.min(Math.max(v, a), b);
  }
  function Audio() {
    audioCtx = new AudioContext();
    sampleRate = audioCtx.sampleRate;
    let attackHitSound;
    let runestoneLandedSound;
    let runestoneMoveSound;
    let powerupCollectSound;
    let enemyMoveSound;
    let enemySwordSound;
    let fireSound;
    let iceSound;
    let zapSound;
    let sigilCaret;
    let sigilCircle;
    let sigilBolt;
    let sigilTriangle;
    let sigilWave;
    let sigilHourglass;
    let sigilGarbage;
    let musicBuffer;
    let activeMusicSource;
    let gainNodeA;
    let gainNodeB;
    let usingA = true;
    const sin = (i) => Math.sin(i);
    const saw = (i) => (i % 6.28 - 3.14) / 6.28;
    const sqr = (i) => clamp(Math.sin(i) * 1e3, -1, 1);
    async function _yield() {
      return new Promise((r) => setTimeout(r, 0));
    }
    function setProgress(p) {
      emit("load-progress", p);
    }
    async function generate(duration, fn) {
      let audioBuffer = audioCtx.createBuffer(1, sampleRate * duration, sampleRate);
      let buffer = audioBuffer.getChannelData(0);
      let N = audioBuffer.length;
      for (let i = 0; i < N; i++) {
        buffer[i] = fn(i * 44100 / sampleRate) * (1 - i / N);
      }
      await _yield();
      return audioBuffer;
    }
    async function init() {
      return;
      attackSound = await generate(0.2, (i) => {
        return 0.05 * saw(i / (0.3 - 220 * Math.exp(-i / 500)));
      });
      attackHitSound = await generate(0.2, (i) => {
        return 0.15 * (sin(i / (20 + i / 150)) * 0.3 + Math.random());
      });
      enemySwordSound = await generate(0.2, (i) => {
        return 0.07 * saw(i / (0.3 - 220 * Math.exp(-i / 500)));
      });
      runestoneLandedSound = await generate(0.25, (i) => {
        return 0.1 * (sqr(i / (120 + i / 250)) * 0.3 + Math.random()) * (sqr(i / 600) * 0.5 + 0.5);
      });
      runestoneMoveSound = await generate(0.1, (i) => {
        return 0.1 * sqr(i / (20 + 150 * Math.exp(-i / 1600)));
      });
      enemyMoveSound = await generate(0.3, (i) => {
        return 0.06 * (sin(i / (14 + i * i / 1e6)) + Math.random() / 2);
      });
      powerupCollectSound = await generate(0.3, (i) => {
        return 0.08 * sin(i / (100 - i / 20));
      });
      fireSound = await generate(0.4, (i) => {
        return 0.16 * Math.random();
      });
      iceSound = await generate(0.4, (i) => {
        return 0.11 * (sqr(i / (30 + i / 500)) * (sqr(i / (1500 + i / 60)) * 0.5 + 0.5) * (sqr(i / (600 + i / 40)) * 0.5 + 0.5));
      });
      zapSound = await generate(0.5, (i) => {
        return 0.15 * (saw(i / (3 + i / 250)) + Math.random() * 0.1);
      });
      function sigilNote(i, pitch, time) {
        const q = Math.pow(2, -pitch / 12) * 18;
        return 0.1 * (saw(i / q) * sin(i / (q * 2 + 3 * sin(i / 2e5)))) * (i / 44100 - time > 0 ? 1 : 0) * Math.exp(-(i / 44100 - time) * 7);
      }
      sigilCaret = await generate(2, (i) => {
        return sigilNote(i, 0, 0) + sigilNote(i, 7, 0.15) + sigilNote(i, 0, 0.3);
      });
      sigilCircle = await generate(2, (i) => {
        return sigilNote(i, 2, 0) + sigilNote(i, 3, 0.15) + sigilNote(i, 5, 0.3);
      });
      sigilBolt = await generate(2, (i) => {
        return sigilNote(i, 12, 0) + sigilNote(i, 6, 0.15) + sigilNote(i, 0, 0.3);
      });
      sigilTriangle = await generate(2, (i) => {
        return sigilNote(i, 10, 0) + sigilNote(i, 10, 0.15) + sigilNote(i, 3, 0.3);
      });
      sigilWave = await generate(2, (i) => {
        return sigilNote(i, 5, 0) + sigilNote(i, 4, 0.15) + sigilNote(i, 5, 0.3);
      });
      sigilHourglass = await generate(2, (i) => {
        return sigilNote(i, 8, 0) + sigilNote(i, 1, 0.15) + sigilNote(i, 4, 0.3);
      });
      sigilGarbage = await generate(2, (i) => {
        return sigilNote(i, -4, 0) + sigilNote(i, -10, 0.15) + sigilNote(i, -4, 0.3);
      });
      const pace = sampleRate * 0.82;
      const drumMusicBuffer = audioCtx.createBuffer(1, pace, sampleRate);
      const drumBuffer2 = drumMusicBuffer.getChannelData(0);
      const W = 0.1 * sampleRate;
      for (let j = 0; j < W; j++) {
        drumBuffer2[j] += 0.06 * (sin(j / (70 + j / 300)) + Math.random() / 3) * (1 - j / W);
        drumBuffer2[parseInt(0.25 * pace) + j] += 0.02 * (saw(j / (80 - j / 2e3)) + Math.random() / 3) * (1 - j / W);
        drumBuffer2[parseInt(0.5 * pace) + j] += 0.06 * Math.random() * (1 - j / W) + 0.06 * (sin(j / (70 + j / 300)) + Math.random() / 3) * (1 - j / W);
        drumBuffer2[parseInt(0.75 * pace) + j] += 0.02 * (saw(j / (80 - j / 2e3)) + Math.random() / 3) * (1 - j / W);
      }
      await _yield();
      function bassNote(j, pitch) {
        const p = Math.pow(2, -pitch / 12) * 80;
        return 0.25 * sin(j / (p + j / 9e3)) * (1 - j / U);
      }
      const bassMusicBuffer = audioCtx.createBuffer(1, 16 * pace, sampleRate);
      const bassBuffer = bassMusicBuffer.getChannelData(0);
      const U = 0.25 * sampleRate;
      const bs = pace * 0.25;
      for (let o = 0; o < 4; o++) {
        const os = o * bs * 16;
        const br = [0, -5, -2, -7][o];
        for (let j = 0; j < U; j++) {
          bassBuffer[j + os] += bassNote(j, 0 + br);
          bassBuffer[j + bs * 3 + os] += bassNote(j, 5 + br);
          bassBuffer[j + bs * 4 + os] += bassNote(j, 7 + br);
          bassBuffer[j + bs * 5 + os] += bassNote(j, 10 + br);
          bassBuffer[j + bs * 7 + os] += bassNote(j, 12 + br);
          bassBuffer[j + bs * 9 + os] += bassNote(j, 12 + br);
          bassBuffer[j + bs * 10 + os] += bassNote(j, 10 + br);
          bassBuffer[j + bs * 11 + os] += bassNote(j, 7 + br);
          bassBuffer[j + bs * 12 + os] += bassNote(j, 12 + br);
          bassBuffer[j + bs * 14 + os] += bassNote(j, 10 + br);
        }
      }
      await _yield();
      function chordNote(j, pitch) {
        const p = Math.pow(2, -pitch / 12) * 20;
        return 0.04 * sin(j / (p + Math.exp(-j / U * 4) * 5)) * clamp(1 - j / (U * 12), 0, 1) * Math.pow(sin(j / 1550) * 0.5 + 0.5, 3);
      }
      const chordMusicBuffer = audioCtx.createBuffer(1, 16 * pace, sampleRate);
      const chordBuffer = chordMusicBuffer.getChannelData(0);
      for (let o = 0; o < 4; o++) {
        const os = o * bs * 16;
        const cr = [[-2, 3, 7], [-2, 2, 7], [-2, 2, 5], [-4, 0, 3]][o];
        for (let j = 0; j < U * 12; j++) {
          chordBuffer[j + os] += chordNote(j, cr[0]);
          chordBuffer[j + os] += chordNote(j, cr[1]);
          chordBuffer[j + os] += chordNote(j, cr[2]);
        }
      }
      await _yield();
      function leadNote(j, pitch) {
        const p = Math.pow(2, -pitch / 12) * 20;
        return 0.034 * saw(j / (p + sin(j / 1e3) * 0.01)) * (1 - j / (U * 2));
      }
      const leadMusicBuffer = audioCtx.createBuffer(1, 16 * pace, sampleRate);
      const leadBuffer = leadMusicBuffer.getChannelData(0);
      for (let j = 0; j < U * 2; j++) {
        leadBuffer[j] += leadNote(j, 7);
        leadBuffer[j + bs * 3] += leadNote(j, 0);
        leadBuffer[j + bs * 6] += leadNote(j, 3);
        leadBuffer[j + bs * 7] += leadNote(j, 5);
        leadBuffer[j + bs * 8] += leadNote(j, 7);
        leadBuffer[j + bs * 11] += leadNote(j, 0);
        leadBuffer[j + bs * 14] += leadNote(j, 3);
        leadBuffer[j + bs * 15] += leadNote(j, 5);
        leadBuffer[j + bs * 16] += leadNote(j, 2);
        leadBuffer[j + bs * 32] += leadNote(j, 5);
        leadBuffer[j + bs * (3 + 32)] += leadNote(j, -2);
        leadBuffer[j + bs * (6 + 32)] += leadNote(j, 2);
        leadBuffer[j + bs * (7 + 32)] += leadNote(j, 3);
        leadBuffer[j + bs * (8 + 32)] += leadNote(j, 5);
        leadBuffer[j + bs * (11 + 32)] += leadNote(j, -2);
        leadBuffer[j + bs * (14 + 32)] += leadNote(j, 3);
        leadBuffer[j + bs * (15 + 32)] += leadNote(j, 2);
        leadBuffer[j + bs * (16 + 32)] += leadNote(j, 0);
      }
      await _yield();
      musicBuffer = audioCtx.createBuffer(1, 8 * 4 * pace, sampleRate);
      const outBuffer = musicBuffer.getChannelData(0);
      for (let i = 0; i < outBuffer.length; i++) {
        outBuffer[i] += drumBuffer2[i % drumBuffer2.length];
        outBuffer[i] += bassBuffer[i % bassBuffer.length];
        outBuffer[i] += chordBuffer[i % chordBuffer.length];
        outBuffer[i] += leadBuffer[i % leadBuffer.length];
      }
      on(ENEMY_BONK, play(attackHitSound));
      on(ENEMY_TAKE_DAMAGE, play(attackHitSound));
      on(RUNESTONE_MOVE, play(runestoneMoveSound));
      on(RUNESTONE_LAND, play(runestoneLandedSound));
      on(POWERUP_ACQUIRED, play(powerupCollectSound));
      on(ENEMY_MOVE, play(enemyMoveSound));
      on(ENEMY_DAMAGE, play(enemySwordSound));
      on(ABILITY_BEAT, (t) => {
        play({
          0: fireSound,
          1: iceSound,
          2: zapSound
        }[t])();
      });
      on(SIGIL_DRAWN, ([type, dir]) => {
        play({
          0: sigilGarbage,
          5: sigilCaret,
          1: sigilCircle,
          3: sigilBolt,
          2: sigilTriangle,
          4: sigilWave,
          6: sigilHourglass
        }[type])();
      });
      gainNodeA = new GainNode(audioCtx);
      gainNodeA.connect(audioCtx.destination);
      gainNodeB = new GainNode(audioCtx);
      gainNodeB.connect(audioCtx.destination);
      music(musicBuffer);
    }
    async function genericSongBuilder([melodySignature, beat], seed, prog1, prog2) {
      const song = [];
      const drums = [];
      const noteLength = [4, 2, 0.5, 3, 4][seed];
      const noteSpace = [1, 0.5, 0.25, 2, 2][seed++];
      const bassNotes = [-15, -20, -19, -12];
      drums.push(
        [seed * seed * 3 * 0.5 % 2, seed % 2],
        [(seed * seed * 3 + seed * 9) * 0.5 % 2, (seed + 1) % 2],
        [(seed * seed * 2 + seed * 11) * 0.5 % 2, (seed + 1) % 2]
      );
      setProgress(prog1);
      for (let i = 0; i < 3; i++) {
        const o = i * 8;
        const q = [0, 3, -5][i];
        for (let j = 0; j < 8; j++) {
          song.push([bassNotes[(seed * 7 + i * 2 + (j >> 1) + j * j * 3) % 4] + q, j + o, 6, 1]);
        }
        for (let j = 0; j < 8 / noteSpace; j++) {
          if ((j + j * j + i + seed * 3) % 7 < 4) {
            song.push([-3 + q + melodySignature[(j + j * j * 2 + i * i * 2 + seed) % melodySignature.length], j * noteSpace + o, noteLength, 2]);
          }
        }
      }
      const targetBuffer = audioCtx.createBuffer(1, sampleRate * 8 * 3 * beat, sampleRate);
      const buffer = targetBuffer.getChannelData(0);
      for (let i = 0; i < song.length; i++) {
        let note, start, duration, amp;
        [note, start, duration, amp] = song[i];
        const baseIdx = parseInt(start * beat * sampleRate);
        const dur = duration * beat * sampleRate;
        for (let i2 = 0; i2 < dur; i2++) {
          let v = 0;
          const envelope = i2 / dur;
          v += amp == 1 ? clamp(sin(i2 / (6 * 2 ** (-note / 12) * 2 * 2) + sin(i2 / 8e3)) * (Math.exp(-envelope * 23) * 44 + 1), -1, 1) * 2 : saw(i2 / (4.03 * 6 * 2 ** (-note / 12) * 2)) * 7;
          buffer[baseIdx + i2] += v * Math.min(envelope * Math.exp(-envelope * (10 + amp * 7)) * 100, 1) / 500;
        }
        await _yield();
        setProgress(prog1 + (prog2 - prog1) * (i / song.length) * 0.8);
      }
      for (let q = 0; q < 44; q += 2) {
        for (let j = 0; j < drums.length; j++) {
          let type, drumStart;
          [drumStart, type] = drums[j];
          const noteOffset = parseInt(0.5 * sampleRate * type);
          const startOffset = parseInt((drumStart + q) * sampleRate * beat);
          for (let k = 0; k < sampleRate * 0.1; k++) {
            buffer[k + startOffset] += drumBuffer[k + noteOffset];
          }
        }
        await _yield();
        setProgress(prog1 + (prog2 - prog1) * (0.8 + 0.2 * (q / 44)));
      }
      return targetBuffer;
    }
    function play(audioBuffer) {
      return () => {
        let source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioCtx.destination);
        source.start();
      };
    }
    ;
    function music(musicBuffer2) {
      let audioToStop = activeMusicSource;
      activeMusicSource = audioCtx.createBufferSource();
      activeMusicSource.buffer = musicBuffer2;
      activeMusicSource.loop = true;
      activeMusicSource.connect(usingA ? gainNodeA : gainNodeB);
      activeMusicSource.start();
      setTimeout(() => {
        audioToStop?.stop();
      }, 700);
      gainNodeA.gain.setTargetAtTime(usingA ? 1 : 0, audioCtx.currentTime, 0.5);
      gainNodeB.gain.setTargetAtTime(usingA ? 0 : 1, audioCtx.currentTime, 0.5);
      usingA = !usingA;
    }
    return {
      init
    };
  }
  var audio_default = Audio;

  // src/color.js
  var BLACK = "#000000";
  var WHITE = "#FFFFFF";
  var LIGHT_GRAY = "#C3C3C3";
  var DARK_RED = "#880015";
  var BROWN = "#B97A57";
  var RED = "#ED1C24";
  var ORANGE = "#FFC90E";
  var GREEN = "#22B14C";
  var TEAL = "#99D9EA";
  var PURPLE = "#A349A4";

  // src/arena.js
  function Arena() {
    let anim = 0;
    function render(ctx2) {
      ctx2.fillStyle = BROWN;
      ctx2.beginPath();
      for (let a = 0; a < Math.PI * 2; a += 0.05) {
        const R = 490 * (1 + Math.cos(a * 5 + anim * 0.3) * 0.03 + Math.cos(a * 9 - anim * 0.5) * 0.02 + +Math.cos(a * 17 + anim * 0.9) * 0.01 + Math.cos(a * 4 + 3) * 0.02);
        if (a == 0) {
          ctx2.moveTo(Math.cos(a) * R, Math.sin(a) * R * 0.6);
        } else {
          ctx2.lineTo(Math.cos(a) * R, Math.sin(a) * R * 0.6);
        }
      }
      ctx2.fill();
    }
    function update(dT) {
      anim += dT * 2;
    }
    return {
      update,
      render,
      order: -1e3
    };
  }
  var arena_default = Arena;

  // src/grim.js
  function Grim(x, y) {
    let self = null;
    let vx = 0;
    let vy = 0;
    let SPEED = 130;
    let angle = 0;
    let anim = 0;
    let keys = {};
    function renderHead(ctx2, C, S, H) {
      ctx2.fillStyle = WHITE;
      ctx2.strokeStyle = WHITE;
      S -= 0.2;
      if (S < 0) {
        const wd = Math.max(Math.min(-16 * S, 14), 0);
        const s = (14 - wd) * 0.5;
        ctx2.lineWidth = wd;
        ctx2.beginPath();
        ctx2.moveTo(C * (8 + s), -26 - s * 0.7 + H);
        ctx2.lineTo(C * (8 + s), -22 + s * 0.7 + H);
        ctx2.stroke();
      }
    }
    function renderCloak(ctx2, C, H) {
      ctx2.fillStyle = BLACK;
      ctx2.strokeStyle = BLACK;
      ctx2.lineWidth = 4;
      ctx2.beginPath();
      const Q = H * 0.5;
      ctx2.moveTo(-7 - Q, 0);
      ctx2.lineTo(-2 - Q, -24 + H);
      ctx2.lineTo(2 + Q, -24 + H);
      ctx2.lineTo(7 + Q, 0);
      ctx2.closePath();
      ctx2.fill();
      ctx2.stroke();
      ctx2.beginPath();
      ctx2.lineTo(-11 * C, -16 + H);
      ctx2.bezierCurveTo(-11 * C, -30 + H, -10 * C, -32 + H, 7 * C, -34 + H);
      ctx2.lineTo(7 * C, -17 + H);
      ctx2.lineTo(0, -22 + H / 2);
      ctx2.closePath();
      ctx2.fill();
      ctx2.stroke();
      ctx2.lineWidth = 18;
      ctx2.beginPath();
      ctx2.moveTo(C * 5, -27 + H);
      ctx2.lineTo(C * 5, -22 + H);
      ctx2.stroke();
    }
    function renderBlade(ctx2, C, S, H) {
      ctx2.fillStyle = LIGHT_GRAY;
      ctx2.strokeStyle = LIGHT_GRAY;
      ctx2.lineWidth = 6;
      ctx2.beginPath();
      ctx2.moveTo(14 * S + 4.5 * C, -45 + H);
      ctx2.lineTo(15 * S + 15 * C, -42 + H);
      ctx2.lineTo(12 * S + 18 * C, -38 + H);
      ctx2.stroke();
    }
    function renderScythe(ctx2, C, S, H) {
      if (S > 0) {
        renderBlade(ctx2, C, S, H);
      }
      if (C >= 0) {
        renderArm(ctx2, C, S, H);
      }
      ctx2.fillStyle = DARK_RED;
      ctx2.strokeStyle = DARK_RED;
      ctx2.lineWidth = 5;
      ctx2.beginPath();
      ctx2.moveTo(13 * S - 7 * C, 1.5 * C + H);
      ctx2.lineTo(13 * S + 3 * C, -33 + H);
      ctx2.lineTo(14 * S + 4 * C, -45 + H);
      ctx2.stroke();
      if (S <= 0) {
        renderBlade(ctx2, C, S, H);
      }
      if (C < 0) {
        renderArm(ctx2, C, S, H);
      }
    }
    function renderArm(ctx2, C, S, H) {
      ctx2.fillStyle = BLACK;
      ctx2.strokeStyle = BLACK;
      ctx2.lineWidth = 6;
      ctx2.beginPath();
      ctx2.moveTo(11 * S - 2 * C, -12 + H);
      ctx2.lineTo(8 * S - 2 * C, -13 + H);
      ctx2.stroke();
    }
    function render(ctx2) {
      retainTransform(() => {
        ctx2.translate(x, y);
        const C = Math.cos(angle);
        const S = Math.sin(angle);
        const H = Math.abs(Math.cos(anim * 12)) * 2;
        if (C < 0) {
          renderScythe(ctx2, C, S, H);
        }
        renderCloak(ctx2, C, H);
        renderHead(ctx2, C, S, H);
        if (C >= 0) {
          renderScythe(ctx2, C, S, H);
        }
      });
    }
    function update(dT) {
      let tx = 0;
      let ty = 0;
      if (keys["ArrowLeft"]) {
        tx -= 1;
      }
      if (keys["ArrowRight"]) {
        tx += 1;
      }
      if (keys["ArrowUp"]) {
        ty -= 1;
      }
      if (keys["ArrowDown"]) {
        ty += 1;
      }
      const M = Math.sqrt(tx * tx + ty * ty);
      if (M > 0.1) {
        tx *= SPEED / M;
        ty *= SPEED / M;
        vx += (tx - vx) * 10 * dT;
        vy += (ty - vy) * 10 * dT;
        anim += dT * 1;
      } else {
        vx += -vx * 5 * dT;
        vy += -vy * 5 * dT;
        anim += dT * 0.3;
      }
      x += vx * dT;
      y += vy * dT;
      angle = -Math.atan2(vy, vx);
      const CM = Math.sqrt(x * x + y * y * 2.8);
      if (CM > 460) {
        x = 460 * x / CM;
        y = 460 * y / CM;
      }
      const gateways = getObjectsByTag("gateway");
      const interaction = getObjectsByTag("interaction")[0];
      let hasGateway = false;
      for (let i = 0; i < gateways.length; i++) {
        if (gateways[i].inRegion(x, y)) {
          hasGateway = true;
          interaction.setGateway(gateways[i]);
          break;
        }
      }
      if (!hasGateway) {
        interaction.setGateway(null);
      }
      self.order = 50 + y / 100;
    }
    function onKeyDown(evt) {
      keys[evt.key] = true;
    }
    function onKeyUp(evt) {
      keys[evt.key] = false;
    }
    function onFocus() {
      keys = {};
    }
    window.addEventListener("focus", onFocus);
    window.addEventListener("keydown", onKeyDown);
    window.addEventListener("keyup", onKeyUp);
    function onRemove() {
      window.removeEventListener("focus", onFocus);
      window.removeEventListener("keydown", onKeyDown);
      window.removeEventListener("keyup", onKeyUp);
    }
    function getX() {
      return x;
    }
    function getY() {
      return y;
    }
    self = {
      update,
      render,
      onRemove,
      getX,
      getY,
      tags: ["grim", "hitbox"],
      order: 50
    };
    return self;
  }
  var grim_default = Grim;

  // src/emote-enum.js
  var EMOTE = {
    TRIANGLE: 0,
    YOTA: 1,
    CIRCLE: 2,
    WAVE: 3
  };

  // src/poof-particle.js
  function PoofParticle(cx, cy, ang) {
    let anim = 0;
    let r1 = Math.random() * 0.6 + 0.9;
    if (!ang) {
      ang = Math.random() * 3 - 1.5;
    }
    function render(ctx2) {
      retainTransform(() => {
        const LW = Math.exp(-anim * 5) * 20 * Math.max(1 - anim / 2, 0);
        ctx2.lineWidth = LW;
        let R1 = 60 * r1 * (1 - Math.exp(-anim * 5)) + anim * 10;
        ctx2.strokeStyle = TEAL;
        ctx2.beginPath();
        ctx2.ellipse(cx, cy + LW * 0.5, R1, R1 / 2, ang * 0.8, 0, 6.28);
        ctx2.stroke();
        ctx2.strokeStyle = WHITE;
        ctx2.beginPath();
        ctx2.ellipse(cx, cy, R1, R1 / 2, ang, 0, 6.28);
        ctx2.stroke();
      });
    }
    function update(dT) {
      anim += dT;
      if (anim > 2) {
        return true;
      }
    }
    return {
      update,
      render,
      order: 100
    };
  }
  var poof_particle_default = PoofParticle;

  // src/soul.js
  function Soul(x, y) {
    let self = null;
    let vx = 0;
    let vy = 0;
    let SPEED = 70 + Math.random() * 40;
    let HEIGHT = 0.9 + Math.random() * 1;
    let WIDTH = 0.9 + Math.random() * 0.4;
    let FACE_HEIGHT = Math.random() * 8;
    let FACE_WIDTH = Math.random() * 2.3 + 1.7;
    let FACE_PLACE = -1 + Math.random() * 8;
    let angle = Math.random() * 7;
    let anim = Math.random() * 100;
    let desiredEmote = null;
    let hunger = 0;
    let hungerAnim = Math.random() * 100;
    let activeGateway = null;
    function getFadeFactor() {
      return 1 - Math.max(hunger - 1, 0);
    }
    function getFaceColor() {
      let q = getFadeFactor();
      let R = 0;
      let G = 162;
      let B = 232;
      if (activeGateway != null && activeGateway.getEmote() == desiredEmote) {
        R = 255;
        G = 255;
        B = 230;
      }
      let A = 1;
      R = R * q + 200 * (1 - q);
      G = G * q + 200 * (1 - q);
      B = B * q + 200 * (1 - q);
      A = A * q + 0.2 * (1 - q);
      return `rgba(${R},${G},${B},${A})`;
    }
    function getTorsoColor() {
      let q = getFadeFactor();
      let R = 63;
      let G = 72;
      let B = 204;
      if (activeGateway != null && activeGateway.getEmote() == desiredEmote) {
        R = 255;
        G = 230;
        B = 170;
      }
      let A = 1;
      R = R * q + 200 * (1 - q);
      G = G * q + 200 * (1 - q);
      B = B * q + 200 * (1 - q);
      A = A * q + 0.2 * (1 - q);
      return `rgba(${R},${G},${B},${A})`;
    }
    function renderFace(ctx2, C, S, H) {
      ctx2.strokeStyle = getFaceColor();
      S -= 0.2;
      if (S < 0) {
        const wd = Math.max(Math.min(-16 * S, 14), 0);
        const s = (14 - wd) * 0.5;
        ctx2.lineWidth = wd * WIDTH;
        ctx2.beginPath();
        ctx2.moveTo(C * (5 + s) * WIDTH, (-20 + H) * HEIGHT - s * 0.7 - 6);
        ctx2.lineTo(C * (5 + s) * WIDTH, (-20 + H) * HEIGHT + s * 0.7 - 2 + FACE_HEIGHT);
        ctx2.stroke();
        if (activeGateway != null) {
          ctx2.strokeStyle = BLACK;
        } else {
          ctx2.strokeStyle = WHITE;
        }
        ctx2.lineWidth = 3 * wd / 14;
        ctx2.beginPath();
        ctx2.moveTo(C * (7 + s) * WIDTH - FACE_WIDTH * S, (-20 + H) * HEIGHT - FACE_PLACE);
        ctx2.lineTo(C * (7 + s) * WIDTH - FACE_WIDTH * S, (-20 + H) * HEIGHT - FACE_PLACE + 0.1);
        ctx2.moveTo(C * (7 + s) * WIDTH + FACE_WIDTH * S, (-20 + H) * HEIGHT - FACE_PLACE);
        ctx2.lineTo(C * (7 + s) * WIDTH + FACE_WIDTH * S, (-20 + H) * HEIGHT - FACE_PLACE + 0.1);
        ctx2.stroke();
      }
    }
    function renderBody(ctx2, C, S, H) {
      const col = getTorsoColor();
      ctx2.fillStyle = col;
      ctx2.strokeStyle = col;
      const Q = H * 3;
      ctx2.lineWidth = 16 * WIDTH + Q;
      ctx2.beginPath();
      ctx2.moveTo(0, -5 - Q * WIDTH * 0.5 - WIDTH * 2);
      ctx2.lineTo(0, (-20 + H * 2) * HEIGHT);
      ctx2.closePath();
      ctx2.fill();
      ctx2.stroke();
      ctx2.lineWidth = 18 * WIDTH;
      ctx2.beginPath();
      ctx2.moveTo(C * 3, (-20 + H) * HEIGHT - 7);
      ctx2.lineTo(C * 3, (-20 + H) * HEIGHT - 2 + FACE_HEIGHT);
      ctx2.stroke();
      ctx2.strokeStyle = col;
      ctx2.lineWidth = 5 * WIDTH;
      ctx2.beginPath();
      ctx2.moveTo(S * 6, (-20 + H) * HEIGHT - 11);
      ctx2.lineTo(S * 7, (-20 + H) * HEIGHT - 16);
      ctx2.moveTo(-S * 6, (-20 + H) * HEIGHT - 11);
      ctx2.lineTo(-S * 7, (-20 + H) * HEIGHT - 16);
      ctx2.stroke();
    }
    function renderEmote(ctx2) {
      if (desiredEmote != null) {
        if (desiredEmote == EMOTE.TRIANGLE) {
          renderTriangleEmote(ctx2, 0);
        } else if (desiredEmote == EMOTE.YOTA) {
          renderYotaEmote(ctx2, 0);
        } else if (desiredEmote == EMOTE.CIRCLE) {
          renderCircleEmote(ctx2, 0);
        } else if (desiredEmote == EMOTE.WAVE) {
          renderWaveEmote(ctx2, 0);
        }
      }
    }
    function renderTriangleEmote(ctx2, dy) {
      ctx2.strokeStyle = `rgba(0,0,0,${Math.cos(hungerAnim) * 0.5 + 0.5})`;
      ctx2.lineWidth = 5;
      ctx2.beginPath();
      ctx2.moveTo(0, -20 * HEIGHT - 34 + dy);
      ctx2.lineTo(7, -20 * HEIGHT - 24 + dy);
      ctx2.lineTo(-7, -20 * HEIGHT - 24 + dy);
      ctx2.closePath();
      ctx2.stroke();
      ctx2.strokeStyle = `rgba(255,192,14,${Math.cos(hungerAnim) * 0.5 + 0.5})`;
      ctx2.lineWidth = 3;
      ctx2.stroke();
    }
    function renderYotaEmote(ctx2, dy) {
      ctx2.strokeStyle = `rgba(0,0,0,${Math.cos(hungerAnim) * 0.5 + 0.5})`;
      ctx2.lineWidth = 5;
      ctx2.beginPath();
      ctx2.moveTo(0, -20 * HEIGHT - 24);
      ctx2.lineTo(0, -20 * HEIGHT - 28);
      ctx2.moveTo(-5, -20 * HEIGHT - 34);
      ctx2.bezierCurveTo(-5, -20 * HEIGHT - 28, 5, -20 * HEIGHT - 28, 5, -20 * HEIGHT - 34);
      ctx2.stroke();
      ctx2.strokeStyle = `rgba(34,200,15,${Math.cos(hungerAnim) * 0.5 + 0.5})`;
      ctx2.lineWidth = 3;
      ctx2.stroke();
    }
    function renderCircleEmote(ctx2, dy) {
      ctx2.strokeStyle = `rgba(0,0,0,${Math.cos(hungerAnim) * 0.5 + 0.5})`;
      ctx2.lineWidth = 5;
      ctx2.beginPath();
      ctx2.arc(0, -20 * HEIGHT - 29 + dy, 6.5, -Math.PI / 2, 1.5 * Math.PI);
      ctx2.lineTo(0, -20 * HEIGHT - 24 + dy);
      ctx2.stroke();
      ctx2.strokeStyle = `rgba(237,28,38,${Math.cos(hungerAnim) * 0.5 + 0.5})`;
      ctx2.lineWidth = 3;
      ctx2.stroke();
    }
    function renderWaveEmote(ctx2, dy) {
      ctx2.strokeStyle = `rgba(0,0,0,${Math.cos(hungerAnim) * 0.5 + 0.5})`;
      ctx2.lineWidth = 5;
      ctx2.beginPath();
      ctx2.moveTo(-7, -20 * HEIGHT - 29 - 3 + dy);
      ctx2.bezierCurveTo(-4, -20 * HEIGHT - 37 - 3 + dy, 4, -20 * HEIGHT - 21 - 3 + dy, 7, -20 * HEIGHT - 29 - 3 + dy);
      ctx2.moveTo(-7, -20 * HEIGHT - 29 + 3 + dy);
      ctx2.bezierCurveTo(-4, -20 * HEIGHT - 37 + 3 + dy, 4, -20 * HEIGHT - 21 + 3 + dy, 7, -20 * HEIGHT - 29 + 3 + dy);
      ctx2.stroke();
      ctx2.strokeStyle = `rgba(163,73,164,${Math.cos(hungerAnim) * 0.5 + 0.5})`;
      ctx2.lineWidth = 3;
      ctx2.stroke();
    }
    function render(ctx2) {
      retainTransform(() => {
        ctx2.translate(x, y);
        const C = Math.cos(angle);
        const S = Math.sin(angle);
        const H = Math.abs(Math.cos(anim * 12)) * 2;
        renderBody(ctx2, C, S, H);
        renderFace(ctx2, C, S, H);
        renderEmote(ctx2);
      });
    }
    function update(dT) {
      let tx = 0;
      let ty = 0;
      const grim = getObjectsByTag("grim")[0];
      if (grim) {
        tx = grim.getX() - x;
        ty = grim.getY() - y;
      }
      const M = Math.sqrt(tx * tx + ty * ty);
      if (M > 55) {
        tx *= SPEED / M;
        ty *= SPEED / M;
        vx += (tx - vx) * 3 * dT;
        vy += (ty - vy) * 3 * dT;
      } else {
        vx += -vx * 5 * dT;
        vy += -vy * 5 * dT;
      }
      let bx = x;
      let by = y;
      x += vx * dT;
      y += vy * dT;
      handleCollision();
      let isMoving = false;
      let bx2 = bx - x;
      let by2 = by - y;
      if (bx2 * bx2 + by2 * by2 < 10 * dT) {
        anim += dT * (0.3 + WIDTH * 0.05);
      } else {
        anim += dT * (1 - HEIGHT * 0.07);
        isMoving = true;
      }
      if (isMoving) {
        angle = -Math.atan2(vy, vx);
      } else {
        angle += Math.cos(anim * 5) * 1 * dT;
      }
      if (desiredEmote !== null) {
        hungerAnim += dT * hunger * 10;
        hunger += dT * 0.05;
        if (hunger > 2) {
          add(new poof_particle_default(x, y - 20 * HEIGHT / 2));
          setTimeout(() => {
            add(new poof_particle_default(x, y - 20 * HEIGHT / 2));
          }, Math.random() * 100 + 50);
          return true;
        }
      }
      const gateways = getObjectsByTag("gateway");
      activeGateway = null;
      for (let i = 0; i < gateways.length; i++) {
        if (gateways[i].inRegion(x, y)) {
          activeGateway = gateways[i];
          activeGateway.refreshActive();
          break;
        }
      }
      self.order = 50 + y / 100;
    }
    function handleCollision() {
      const hitboxes = getObjectsByTag("hitbox");
      const R = 14;
      for (let i = 0; i < hitboxes.length; i++) {
        if (hitboxes[i] == self) {
          continue;
        }
        const dx = hitboxes[i].getX() - x;
        const dy = hitboxes[i].getY() - y;
        const M = Math.sqrt(dx * dx + dy * dy);
        if (M < R + R) {
          x = hitboxes[i].getX() - dx / M * R * 2 + Math.random() - 0.5;
          y = hitboxes[i].getY() - dy / M * R * 2 + Math.random() - 0.5;
        }
      }
    }
    function getX() {
      return x;
    }
    function getY() {
      return y;
    }
    function onAssignEmote({ soul, emote }) {
      if (self !== soul) {
        return;
      }
      desiredEmote = emote;
    }
    function onConsume({ gateway, emote }) {
      if (activeGateway == gateway && desiredEmote == emote) {
        remove([self]);
      }
    }
    on("assign-emote", onAssignEmote);
    on("consume", onConsume);
    function onRemove() {
      off("assign-emote", onAssignEmote);
      off("consume", onConsume);
    }
    self = {
      update,
      render,
      getX,
      getY,
      onRemove,
      tags: ["soul", "hitbox"],
      order: 40
    };
    return self;
  }
  var soul_default = Soul;

  // src/gateway.js
  function Gateway(cx, cy, emote) {
    let activeTimer = 0;
    let spawningAnim = 0;
    function render(ctx2) {
      retainTransform(() => {
        if (spawningAnim > 0.5) {
          ctx2.lineWidth = 5;
          if (emote == EMOTE.TRIANGLE)
            renderTriangleEmote(ctx2);
          if (emote == EMOTE.YOTA)
            renderYotaEmote(ctx2);
          if (emote == EMOTE.CIRCLE)
            renderCircleEmote(ctx2);
          if (emote == EMOTE.WAVE)
            renderWaveEmote(ctx2);
          if (activeTimer > 0) {
            if (emote == EMOTE.TRIANGLE)
              ctx2.strokeStyle = ORANGE;
            if (emote == EMOTE.YOTA)
              ctx2.strokeStyle = GREEN;
            if (emote == EMOTE.CIRCLE)
              ctx2.strokeStyle = RED;
            if (emote == EMOTE.WAVE)
              ctx2.strokeStyle = PURPLE;
          } else {
            ctx2.strokeStyle = LIGHT_GRAY;
          }
          ctx2.beginPath();
          for (let i = 0; i < 6; i++) {
            const dx = Math.cos(i / 6 * 6.28) * 70;
            const dy = Math.sin(i / 6 * 6.28) * 70 / 2;
            if (i == 0)
              ctx2.moveTo(cx + dx, cy + dy);
            else
              ctx2.lineTo(cx + dx, cy + dy);
          }
          ctx2.closePath();
          ctx2.moveTo(cx + 55, cy);
          ctx2.ellipse(cx, cy, 55, 55 / 2, 0, 0, 6.28);
          ctx2.stroke();
        }
        if (spawningAnim < 1) {
          const S = 1.1 - 1.1 * Math.exp(-spawningAnim * 4);
          const H = 1 * Math.exp(-spawningAnim * 5) + 0.02;
          const alpha = Math.min(spawningAnim * 2, 1) * Math.min(Math.max(5 - spawningAnim * 5, 0), 1);
          ctx2.fillStyle = `rgba(255,255,255,${alpha})`;
          for (let i = 0; i < 6; i++) {
            ctx2.beginPath();
            const dx = Math.cos(i / 6 * 6.28) * 70 * S;
            const dy = Math.sin(i / 6 * 6.28) * 70 / 2 * S;
            const dx2 = Math.cos((i + 1) / 6 * 6.28) * 70 * S;
            const dy2 = Math.sin((i + 1) / 6 * 6.28) * 70 / 2 * S;
            ctx2.moveTo(cx + dx, cy + dy);
            ctx2.lineTo(cx + dx2, cy + dy2);
            ctx2.lineTo(cx + dx2, cy + dy2 - 400 * H);
            ctx2.lineTo(cx + dx, cy + dy - 400 * H);
            ctx2.fill();
          }
        }
      });
    }
    function renderTriangleEmote(ctx2) {
      ctx2.strokeStyle = ORANGE;
      ctx2.lineWidth = 5;
      ctx2.beginPath();
      ctx2.moveTo(cx + 0, cy - 24);
      ctx2.lineTo(cx + 44, cy + 12);
      ctx2.lineTo(cx + -44, cy + 12);
      ctx2.closePath();
      ctx2.stroke();
    }
    function renderYotaEmote(ctx2) {
      ctx2.strokeStyle = GREEN;
      ctx2.lineWidth = 5;
      ctx2.beginPath();
      ctx2.moveTo(cx, cy + 23);
      ctx2.lineTo(cx, cy + 5);
      ctx2.moveTo(cx - 40, cy - 14);
      ctx2.bezierCurveTo(cx - 30, cy + 8, cx + 30, cy + 8, cx + 40, cy - 14);
      ctx2.stroke();
    }
    function renderCircleEmote(ctx2) {
      ctx2.strokeStyle = RED;
      ctx2.lineWidth = 5;
      ctx2.beginPath();
      ctx2.ellipse(cx, cy, 33, 21, 0, 0, 2 * Math.PI);
      ctx2.moveTo(cx, cy - 21);
      ctx2.lineTo(cx, cy + 21);
      ctx2.stroke();
    }
    function renderWaveEmote(ctx2, dy) {
      ctx2.strokeStyle = PURPLE;
      ctx2.lineWidth = 5;
      ctx2.beginPath();
      ctx2.moveTo(cx - 45, cy - 10);
      ctx2.bezierCurveTo(cx - 15, cy - 30, cx + 15, cy + 10, cx + 45, cy - 10);
      ctx2.moveTo(cx - 45, cy + 10);
      ctx2.bezierCurveTo(cx - 15, cy - 10, cx + 15, cy + 30, cx + 45, cy + 10);
      ctx2.stroke();
    }
    function update(dT) {
      activeTimer -= dT;
      spawningAnim += dT;
    }
    function inRegion(tx, ty) {
      const dx = tx - cx;
      const dy = ty - cy;
      return spawningAnim > 1 && dx * dx + dy * dy * 2 < 65 * 65;
    }
    function isTooCloseToGate(tx, ty) {
      const dx = tx - cx;
      const dy = ty - cy;
      return dx * dx + dy * dy * 2 < 130 * 130;
    }
    function refreshActive() {
      activeTimer = 0.2;
    }
    function getX() {
      return cx;
    }
    function getY() {
      return cy;
    }
    function getEmote() {
      return emote;
    }
    function getCurrentWord() {
      return "QWE";
    }
    return {
      update,
      render,
      inRegion,
      isTooCloseToGate,
      refreshActive,
      getX,
      getY,
      getEmote,
      getCurrentWord,
      tags: ["gateway"],
      order: -200
    };
  }
  var gateway_default = Gateway;

  // src/soul-manager.js
  function SoulManager() {
    let soulRequests = /* @__PURE__ */ new Map();
    let tick2 = 0;
    let availableEmotes = [EMOTE.TRIANGLE, EMOTE.YOTA, EMOTE.CIRCLE, EMOTE.WAVE];
    function assignSoulEmote(soul, emote) {
      if (soul == null) {
        return;
      }
      soulRequests.set(soul, {
        emote,
        time: Date.now()
      });
      emit("assign-emote", { soul, emote });
    }
    function getSoulEmote(soul) {
      return soulRequests.get(soul);
    }
    function isSoulAssigned(soul) {
      return getSoulEmote(soul) !== void 0;
    }
    function getNumAssignments() {
      return soulRequests.size;
    }
    function clearAssignement(soul) {
      return soulRequests.delete(soul);
    }
    function clearAll() {
      soulRequests.clear();
    }
    function getRandomFreeSoul() {
      const souls = getObjectsByTag("soul");
      const freeSouls = souls.filter((x) => !isSoulAssigned(x));
      if (freeSouls.length == 0) {
        return null;
      }
      return freeSouls[Math.floor(Math.random() * freeSouls.length)];
    }
    function getRandomEmote() {
      return availableEmotes[Math.floor(Math.random() * availableEmotes.length)];
    }
    function getNumGateways() {
      return getObjectsByTag("gateway").length;
    }
    function spawnRandomGateway() {
      const emote = getRandomEmote();
      const gateways = getObjectsByTag("gateway");
      let sx = 0;
      let sy = 0;
      for (let i = 0; i < 200; i++) {
        sx = (Math.random() - 0.5) * 800;
        sy = (Math.random() - 0.5) * 600;
        const CM = Math.sqrt(sx * sx + sy * sy * 2.8);
        if (CM > 390) {
          sx = 390 * sx / CM;
          sy = 390 * sy / CM;
        }
        let isValid = true;
        for (let j = 0; j < gateways.length; j++) {
          if (gateways[j].isTooCloseToGate(sx, sy)) {
            isValid = false;
            break;
          }
        }
        if (isValid) {
          break;
        }
      }
      add(new gateway_default(sx, sy, emote));
    }
    function render(ctx2) {
    }
    function update(dT) {
      tick2 += dT;
      if (tick2 < 1) {
        return;
      }
      tick2 -= 1;
      const numAssignments = getNumAssignments();
      if (numAssignments == 0) {
        assignSoulEmote(getRandomFreeSoul(), getRandomEmote());
      } else {
        if (Math.random() > 0.75) {
          assignSoulEmote(getRandomFreeSoul(), getRandomEmote());
        }
      }
      if (getNumGateways() < availableEmotes.length) {
        spawnRandomGateway();
      }
    }
    return {
      update,
      render,
      tags: ["soul-manager"],
      order: 0
    };
  }
  var soul_manager_default = SoulManager;

  // src/hex-particle.js
  function HexParticle(cx, cy, emote) {
    let anim = 0;
    let R = 255;
    let G = 255;
    let B = 255;
    if (emote == EMOTE.TRIANGLE) {
      R = 255;
      G = 192;
      B = 14;
    }
    if (emote == EMOTE.YOTA) {
      R = 24;
      G = 200;
      B = 15;
    }
    if (emote == EMOTE.CIRCLE) {
      R = 237;
      G = 28;
      B = 38;
    }
    if (emote == EMOTE.WAVE) {
      R = 163;
      G = 73;
      B = 164;
    }
    function render(ctx2) {
      retainTransform(() => {
        const S = 1 + (1 - Math.exp(-anim * 2));
        const H = 1;
        const alpha = Math.max(1 - anim, 0);
        ctx2.fillStyle = `rgba(${R},${G},${B},${alpha})`;
        for (let i = 0; i < 6; i++) {
          ctx2.beginPath();
          const dx = Math.cos(i / 6 * 6.28) * 70 * S;
          const dy = Math.sin(i / 6 * 6.28) * 70 / 2 * S;
          const dx2 = Math.cos((i + 1) / 6 * 6.28) * 70 * S;
          const dy2 = Math.sin((i + 1) / 6 * 6.28) * 70 / 2 * S;
          ctx2.moveTo(cx + dx, cy + dy);
          ctx2.lineTo(cx + dx2, cy + dy2);
          ctx2.lineTo(cx + dx2, cy + dy2 - 400 * H);
          ctx2.lineTo(cx + dx, cy + dy - 400 * H);
          ctx2.fill();
        }
      });
    }
    function update(dT) {
      anim += dT * 2;
      if (anim > 1) {
        return true;
      }
    }
    return {
      update,
      render,
      order: 900
    };
  }
  var hex_particle_default = HexParticle;

  // src/letter-particle.js
  function LetterParticle(cx, cy, text) {
    let anim = 0;
    function render(ctx2) {
      retainTransform(() => {
        const s = 1 + anim * 1;
        ctx2.translate(cx, cy);
        ctx2.scale(s, s);
        ctx2.translate(0, -100);
        ctx2.font = "40px monospace";
        const textWidth = ctx2.measureText(text).width;
        const xOffset = -textWidth / 2;
        ctx2.fillStyle = `rgba(255,255,0,${Math.max(1 - anim * 2, 0)})`;
        ctx2.fillText(text, xOffset, 0);
      });
    }
    function update(dT) {
      anim += dT * 2;
      if (anim > 0.5) {
        return true;
      }
    }
    return {
      update,
      render,
      order: 1005
    };
  }
  var letter_particle_default = LetterParticle;

  // src/interaction.js
  function Interaction() {
    let cx = 0;
    let cy = 0;
    let text = " ";
    let filledText = "";
    let numFilled = 0;
    let nextLetterText = "";
    let activeGateway = null;
    let anim = 0;
    let pulse = 100;
    const vOffset = -100;
    function render(ctx2) {
      if (activeGateway == null) {
        return;
      }
      retainTransform(() => {
        ctx2.font = "40px monospace";
        ctx2.lineWidth = 10 + Math.exp(-pulse * 10) * 5;
        const L = 0 + Math.exp(-pulse * 20) * 200;
        ctx2.strokeStyle = `rgb(${L},${L},${L})`;
        const textWidth = ctx2.measureText(text).width;
        const xOffset = -textWidth / 2;
        ctx2.strokeText(text, cx + xOffset, cy + vOffset);
        ctx2.fillStyle = "#333";
        ctx2.fillText(text, cx + xOffset, cy + vOffset);
        ctx2.fillStyle = "#fff";
        ctx2.fillText(filledText, cx + xOffset, cy + vOffset);
        if (Math.cos(anim * 20) > 0) {
          ctx2.fillStyle = "#ff0";
          ctx2.fillText(nextLetterText, cx + xOffset, cy + vOffset);
        }
      });
    }
    function updateFilledText() {
      let filledChars = text.split("");
      for (let i = numFilled; i < text.length; i++) {
        filledChars[i] = " ";
      }
      filledText = filledChars.join("");
      nextLetterText = [...new Array(numFilled).fill(" "), text[numFilled], ...new Array(text.length - numFilled - 1).fill(" ")].join("");
    }
    updateFilledText();
    function update(dT) {
      anim += dT;
      pulse += dT;
    }
    function setGateway(g) {
      if (g != null) {
        cx = g.getX();
        cy = g.getY();
        text = g.getCurrentWord();
        if (g != activeGateway) {
          updateFilledText();
        }
      } else {
        numFilled = 0;
        pulse = 100;
        updateFilledText();
      }
      activeGateway = g;
    }
    function onKeyDown(evt) {
      if (activeGateway == null) {
        return;
      }
      const charKey = evt.key.toUpperCase();
      const keyCode = evt.keyCode;
      if (keyCode >= 65 && keyCode <= 90 || keyCode >= 97 && keyCode <= 122) {
        if (text[numFilled]?.toUpperCase() == charKey) {
          emit("interact-fill");
          numFilled += 1;
          pulse = 0;
          add(new letter_particle_default(cx, cy, nextLetterText));
          if (numFilled == text.length) {
            emit("consume", { gateway: activeGateway, emote: activeGateway.getEmote() });
            add(new hex_particle_default(activeGateway.getX(), activeGateway.getY(), activeGateway.getEmote()));
            remove([activeGateway]);
            activeGateway = null;
          } else {
            updateFilledText();
          }
        } else {
          emit("interact-error");
          numFilled = 0;
          updateFilledText();
        }
      }
    }
    window.addEventListener("keydown", onKeyDown);
    function onRemove() {
      window.removeEventListener("keydown", onKeyDown);
    }
    return {
      update,
      render,
      setGateway,
      onRemove,
      tags: ["interaction"],
      order: 1e3
    };
  }
  var interaction_default = Interaction;

  // src/main.js
  function initialize() {
    add(new arena_default());
    add(new soul_manager_default());
    add(new interaction_default());
    add(new grim_default(0, 0));
    for (let i = 0; i < 6; i++) {
      add(new soul_default(-50 - 15 * i, Math.cos(i * 2) * 20));
    }
    audio_default().init();
  }
  initialize();
})();
</script>